<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATEM Program Stream</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body class="min-h-screen bg-black text-white font-sans">
    <div class="flex h-screen">
        <!-- Main video area -->
        <div class="flex-1 flex flex-col p-6">
            <!-- Header -->
            <div class="mb-6">
                <h1 class="text-4xl font-bold text-center mb-2">ATEM Mini Pro Stream</h1>
                <div id="stats" class="text-center text-gray-400 font-mono text-sm"></div>
            </div>
            
            <!-- Video container - takes up remaining space -->
            <div class="flex-1 flex items-center justify-center p-4">
                <div id="videoContainer" class="w-full h-full bg-gray-900 border-2 border-gray-700 rounded-lg shadow-2xl overflow-hidden"></div>
            </div>
        </div>
        
        <!-- Control panel -->
        <div class="w-80 bg-gray-900 border-l border-gray-700 p-6 flex flex-col">
            <!-- Top controls section -->
            <div class="space-y-6">
                <!-- Connection Controls -->
                <div class="space-y-4">
                    <h2 class="text-xl font-semibold text-gray-200 border-b border-gray-700 pb-2">Connection</h2>
                    <div class="space-y-3">
                        <button id="connectBtn" onclick="connect()" class="w-full px-4 py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors">
                            Connect
                        </button>
                        <button id="disconnectBtn" onclick="disconnect()" disabled class="w-full px-4 py-3 bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors">
                            Disconnect
                        </button>
                        <button onclick="toggleAudio()" class="w-full px-4 py-3 bg-purple-600 hover:bg-purple-700 text-white font-medium rounded-lg transition-colors">
                            Toggle Audio
                        </button>
                    </div>
                </div>
                
                <!-- ATEM Stream Controls -->
                <div class="space-y-4">
                    <h2 class="text-xl font-semibold text-gray-200 border-b border-gray-700 pb-2">ATEM Stream Control</h2>
                    <div class="space-y-3">
                        <button id="startStreamBtn" onclick="startATEMStream()" class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors">
                            Start Stream
                        </button>
                        <button id="stopStreamBtn" onclick="stopATEMStream()" class="w-full px-4 py-3 bg-orange-600 hover:bg-orange-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors">
                            Stop Stream
                        </button>
                    </div>
                </div>
                
                <!-- ATEM Recording Controls -->
                <div class="space-y-4">
                    <h2 class="text-xl font-semibold text-gray-200 border-b border-gray-700 pb-2">ATEM Recording Control</h2>
                    <div class="space-y-3">
                        <button id="startRecordBtn" onclick="startATEMRecord()" class="w-full px-4 py-3 bg-red-600 hover:bg-red-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors">
                            Start Recording
                        </button>
                        <button id="stopRecordBtn" onclick="stopATEMRecord()" class="w-full px-4 py-3 bg-gray-600 hover:bg-gray-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-medium rounded-lg transition-colors">
                            Stop Recording
                        </button>
                    </div>
                    <div id="recordStatus" class="flex items-center justify-between px-3 py-2 bg-gray-800 border border-gray-600 rounded text-sm">
                        <span class="text-gray-300">Recording Status:</span>
                        <div class="flex items-center space-x-2">
                            <div class="w-2 h-2 bg-gray-500 rounded-full"></div>
                            <span class="text-gray-400 font-medium">Stopped</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Status section at bottom -->
            <div class="mt-auto pt-6">
                <div id="status" class="flex items-center justify-between px-3 py-2 bg-gray-800 border border-gray-600 rounded text-sm">
                    <span class="text-gray-300">Stream Status:</span>
                    <div class="flex items-center space-x-2">
                        <div class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>
                        <span class="text-red-400 font-medium">Disconnected</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        const statusDiv = document.getElementById('status');
        const statsDiv = document.getElementById('stats');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const startStreamBtn = document.getElementById('startStreamBtn');
        const stopStreamBtn = document.getElementById('stopStreamBtn');
        const startRecordBtn = document.getElementById('startRecordBtn');
        const stopRecordBtn = document.getElementById('stopRecordBtn');
        const recordStatusDiv = document.getElementById('recordStatus');
        
        let video = null;
        let hls = null;
        let startTime = 0;
        let statusWs = null;
        let lastStreamingStatus = null;
        let atemConnected = false;
        
        function updateStatus(message, type) {
            const dot = statusDiv.querySelector('.w-2.h-2');
            const text = statusDiv.querySelector('span:last-child');
            
            text.textContent = message;
            
            if (type === 'connected') {
                dot.className = 'w-2 h-2 bg-green-500 rounded-full';
                text.className = 'text-green-400 font-medium';
            } else if (type === 'connecting') {
                dot.className = 'w-2 h-2 bg-yellow-500 rounded-full animate-pulse';
                text.className = 'text-yellow-400 font-medium';
            } else {
                dot.className = 'w-2 h-2 bg-red-500 rounded-full animate-pulse';
                text.className = 'text-red-400 font-medium';
            }
        }
        
        function updateStats() {
            // Stats removed - will show stream status instead
        }
        
        function connect() {
            updateStatus('Connecting...', 'connecting');
            statsDiv.textContent = '';
            connectBtn.disabled = true;
            
            // Connect to status WebSocket (Vite proxy will handle this)
            statusWs = new WebSocket('ws://localhost:5173/status');
            
            statusWs.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'atem_status') {
                    // Check if status changed
                    if (lastStreamingStatus !== null && lastStreamingStatus !== data.streaming) {
                        // Status changed - refresh the stream
                        if (data.streaming) {
                            statsDiv.textContent = 'ATEM stream started - refreshing...';
                        } else {
                            statsDiv.textContent = 'ATEM stream stopped - refreshing...';
                        }
                        setTimeout(() => {
                            if (video) {
                                refreshStream();
                            } else {
                                console.log('Video element not ready for refresh, skipping');
                                // Just update status if video not ready
                                if (data.streaming) {
                                    statsDiv.textContent = 'Receiving ATEM stream';
                                } else {
                                    statsDiv.textContent = 'No ATEM stream received';
                                }
                            }
                        }, 3000);
                    } else {
                        // Status unchanged - just update display
                        if (data.streaming) {
                            statsDiv.textContent = 'Receiving ATEM stream';
                        } else {
                            statsDiv.textContent = 'No ATEM stream received';
                        }
                    }
                    lastStreamingStatus = data.streaming;
                } else if (data.type === 'atem_streaming_connection') {
                    atemConnected = data.connected;
                    updateATEMStatus(data.connected ? 'Streaming Port Connected' : 'Streaming Port Disconnected', data.connected ? 'connected' : 'disconnected');
                    startStreamBtn.disabled = !data.connected;
                    stopStreamBtn.disabled = !data.connected;
                    startRecordBtn.disabled = !data.connected;
                    stopRecordBtn.disabled = !data.connected;
                } else if (data.type === 'atem_recording_status') {
                    // Update recording status based on real ATEM status
                    updateRecordStatus(data.recording ? 'Recording' : 'Stopped', data.recording ? 'recording' : 'stopped');
                }
            };
            
            statusWs.onclose = () => {
                statsDiv.textContent = 'Status connection lost';
            };
            
            // Create video element  
            video = document.createElement('video');
            video.controls = false;
            video.autoplay = true;
            video.muted = true;
            video.playsInline = true;
            video.style.width = '95%';
            video.style.height = '95%';
            video.style.objectFit = 'contain';
            video.style.borderRadius = '8px';
            
            // Add video to container
            const container = document.getElementById('videoContainer');
            container.innerHTML = '';
            container.appendChild(video);
            
            if (Hls.isSupported()) {
                hls = new Hls({
                    maxBufferLength: 1,        // 1 second max buffer
                    maxMaxBufferLength: 2,     // 2 seconds absolute max
                    liveSyncDurationCount: 1,  // Sync to 1 segment from live edge
                    liveMaxLatencyDurationCount: 2, // Max 2 segments behind
                    maxBufferSize: 1000000,    // 1MB max buffer size
                    maxBufferHole: 0.1,        // Fill holes > 0.1s
                    lowLatencyMode: true,      // Enable low latency mode
                    backBufferLength: 2,       // Keep only 2 seconds of back buffer
                    enableWorker: false,       // Disable worker to reduce console noise
                    manifestLoadingTimeOut: 1000,    // 1 second timeout
                    manifestLoadingMaxRetry: 10,     // More retries
                    manifestLoadingRetryDelay: 500   // 500ms between retries
                });
                
                hls.loadSource('/stream.m3u8');
                hls.attachMedia(video);
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    updateStatus('Stream loaded - playing', 'connected');
                    startTime = Date.now();
                    
                    video.play().catch(e => {
                        // Autoplay failed, show unmute button
                        updateStatus('Click to unmute and play', 'connecting');
                        video.onclick = () => {
                            video.muted = false;
                            video.play();
                            video.onclick = null;
                            updateStatus('Stream loaded - playing', 'connected');
                        };
                    });
                });
                
                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.type === 'networkError' && data.details === 'manifestLoadError') {
                        updateStatus('Waiting for stream...', 'connecting');
                    } else if (data.details === 'bufferStalledError' || 
                               data.details === 'bufferAppendError' ||
                               data.details === 'fragLoadError' ||
                               data.details === 'fragParsingError') {
                        // Ignore common streaming errors
                    } else if (data.fatal) {
                        console.error('Fatal HLS error:', data);
                    }
                });
                
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                video.src = '/stream.m3u8';
                video.addEventListener('loadedmetadata', () => {
                    updateStatus('Stream loaded - playing', 'connected');
                    startTime = Date.now();
                });
            }
            
            disconnectBtn.disabled = false;
        }
        
        function disconnect() {
            if (statusWs) {
                statusWs.close();
                statusWs = null;
            }
            if (hls) {
                hls.destroy();
                hls = null;
            }
            if (video) {
                video.pause();
                video.src = '';
                video = null;
            }
            
            document.getElementById('videoContainer').innerHTML = '';
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            updateStatus('Disconnected', 'disconnected');
            statsDiv.textContent = '';
        }
        
        function refreshStream() {
            console.log('refreshStream called, video exists:', !!video, 'hls exists:', !!hls);
            
            if (hls) {
                hls.destroy();
                hls = null;
            }
            if (video) {
                video.pause();
                video.src = '';
            }
            
            // Apply proper video styling
            if (video) {
                video.style.width = '95%';
                video.style.height = '95%';
                video.style.objectFit = 'contain';
                video.style.borderRadius = '8px';
            }
            
            // Recreate HLS connection only if video element exists
            if (video && Hls.isSupported()) {
                hls = new Hls({
                    maxBufferLength: 1,
                    maxMaxBufferLength: 2,
                    liveSyncDurationCount: 1,
                    liveMaxLatencyDurationCount: 2,
                    maxBufferSize: 1000000,
                    maxBufferHole: 0.1,
                    lowLatencyMode: true,
                    backBufferLength: 2,
                    enableWorker: false,
                    manifestLoadingTimeOut: 1000,
                    manifestLoadingMaxRetry: 10,
                    manifestLoadingRetryDelay: 500
                });
                
                hls.loadSource('/stream.m3u8');
                hls.attachMedia(video);
                
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    updateStatus('Stream refreshed - playing', 'connected');
                    // Update ATEM status to current state
                    if (lastStreamingStatus) {
                        statsDiv.textContent = 'Receiving ATEM stream';
                    } else {
                        statsDiv.textContent = 'No ATEM stream received';
                    }
                    video.play().catch(e => {
                        updateStatus('Click to unmute and play', 'connecting');
                        video.onclick = () => {
                            video.muted = false;
                            video.play();
                            video.onclick = null;
                            updateStatus('Stream refreshed - playing', 'connected');
                        };
                    });
                });
                
                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.type === 'networkError' && data.details === 'manifestLoadError') {
                        updateStatus('Waiting for stream...', 'connecting');
                        // Update ATEM status to current state
                        if (lastStreamingStatus) {
                            statsDiv.textContent = 'Receiving ATEM stream';
                        } else {
                            statsDiv.textContent = 'No ATEM stream received';
                        }
                    } else if (data.fatal) {
                        console.error('Fatal HLS error:', data);
                    }
                });
            }
        }
        
        function toggleAudio() {
            if (video) {
                video.muted = !video.muted;
            }
        }
        
        function updateATEMStatus(message, type) {
            const dot = atemStatusDiv.querySelector('.w-2.h-2');
            const text = atemStatusDiv.querySelector('span:last-child');
            
            text.textContent = message;
            
            if (type === 'connected') {
                dot.className = 'w-2 h-2 bg-green-500 rounded-full';
                text.className = 'text-green-400 font-medium';
            } else {
                dot.className = 'w-2 h-2 bg-red-500 rounded-full';
                text.className = 'text-red-400 font-medium';
            }
        }
        
        async function startATEMStream() {
            try {
                startStreamBtn.disabled = true;
                const response = await fetch('/api/atem/start-stream', { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    console.log('Stream start command sent successfully');
                } else {
                    console.error('Failed to start stream:', result.error);
                    alert('Failed to start stream: ' + result.error);
                }
            } catch (error) {
                console.error('Error starting stream:', error);
                alert('Error starting stream: ' + error.message);
            } finally {
                startStreamBtn.disabled = false;
            }
        }
        
        async function stopATEMStream() {
            try {
                stopStreamBtn.disabled = true;
                const response = await fetch('/api/atem/stop-stream', { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    console.log('Stream stop command sent successfully');
                } else {
                    console.error('Failed to stop stream:', result.error);
                    alert('Failed to stop stream: ' + result.error);
                }
            } catch (error) {
                console.error('Error stopping stream:', error);
                alert('Error stopping stream: ' + error.message);
            } finally {
                stopStreamBtn.disabled = false;
            }
        }
        
        function updateRecordStatus(message, type) {
            const dot = recordStatusDiv.querySelector('.w-2.h-2');
            const text = recordStatusDiv.querySelector('span:last-child');
            
            text.textContent = message;
            
            if (type === 'recording') {
                dot.className = 'w-2 h-2 bg-red-500 rounded-full animate-pulse';
                text.className = 'text-red-400 font-medium';
            } else if (type === 'connecting') {
                dot.className = 'w-2 h-2 bg-yellow-500 rounded-full animate-pulse';
                text.className = 'text-yellow-400 font-medium';
            } else if (type === 'error') {
                dot.className = 'w-2 h-2 bg-orange-500 rounded-full';
                text.className = 'text-orange-400 font-medium';
            } else {
                dot.className = 'w-2 h-2 bg-gray-500 rounded-full';
                text.className = 'text-gray-400 font-medium';
            }
        }
        
        async function startATEMRecord() {
            try {
                startRecordBtn.disabled = true;
                updateRecordStatus('Starting...', 'connecting');
                
                const response = await fetch('/api/atem/start-record', { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    console.log('Recording start command sent successfully');
                    // Status will be updated by real ATEM response via WebSocket
                } else {
                    console.error('Failed to start recording:', result.error);
                    alert('Failed to start recording: ' + result.error);
                    updateRecordStatus('Error', 'error');
                }
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error starting recording: ' + error.message);
                updateRecordStatus('Error', 'error');
            } finally {
                startRecordBtn.disabled = false;
            }
        }
        
        async function stopATEMRecord() {
            try {
                stopRecordBtn.disabled = true;
                updateRecordStatus('Stopping...', 'connecting');
                
                const response = await fetch('/api/atem/stop-record', { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    console.log('Recording stop command sent successfully');
                    // Status will be updated by real ATEM response via WebSocket
                } else {
                    console.error('Failed to stop recording:', result.error);
                    alert('Failed to stop recording: ' + result.error);
                    updateRecordStatus('Error', 'error');
                }
            } catch (error) {
                console.error('Error stopping recording:', error);
                alert('Error stopping recording: ' + error.message);
                updateRecordStatus('Error', 'error');
            } finally {
                stopRecordBtn.disabled = false;
            }
        }
        
        // Update stats every 200ms for real-time feedback
        setInterval(updateStats, 200);
        
        // Auto-connect on load
        window.addEventListener('load', () => {
            setTimeout(connect, 1000);
        });
    </script>
</body>
</html>